**架构**:计算机系统的总体设计或结构,包括其硬件和⽀持系统运行 的软件,尤其是微处理器内部的结构 **构件**：一组基本的构成要素
**连接件**：这些要素之间的连接关系,
**物理分布**：这些要素连接之后形成的拓扑结构
**约束**：要素或连接关系上的限制条件 
**性能**：质量 
**架构公式** = 构件 + 连接件 + 拓扑结构 + 约束 + 质量 
**软件架构**(SA)：提供了一个结构、行为和属性的高级抽象；从一 个较高的层次来考虑组成系统的构件、构件之间的连接,以及由 构件与构件交互形成的拓扑结构；这些要素应该满⾜一定的限制, 遵循一定的设计规则,能够在一定的环境下进行演化；反映系统 开发中具有重要影响的设计决策,便于各种⼈员的交流,反映多种 关注,据此开发的系统能完成系统既定的功能和性能需求 
**架构规模**:对于大规模的复杂软件系统来说,对系统全局结构的设 计⽐起对算法的 选择和数据结构的设计明显重要得多 
**目标**: 建⽴一个一致的系统及其视图集,并表达为最终用户和软件 设计者需 要的结构形式,支持用户和设计者之间的交流与理解; 分为两方面: 外向目标：建立满足最终用户要求的系统需求; 内向目 标：建立满足系统设计者需要以及易于系统实现、维护和扩展 的系统构件构成。 
**作用**：1.交流的手段: 在软件设计者、最终用户之间方便的交流； 2. 可传递的、可复用的模型(可重复利用的、可转移的系统抽象): 用到其它的项目、提高大规模重复利用率；3.关键决策的体现:折 衷,关于性能与安全性、可维护性与可靠性、当前开发费用和未 来开发代价
**意义**：SA是软件开发过程初期的产品,在开发的早期 阶段就考虑系统的正确设计与方案选择,为以后开发、测试、维 护各个阶段提供了保证 
**架构师关注**:软件质量, 各种因素….
**中间件**是一组程序,应用于分布式系统各应用之中,屏蔽底层通讯和提供公共服务,保障系统的高可靠性、高可用性、高灵活性 分布式应用借助中间件在不同技术之间共享资源 ● 位于客户机和服务 器的操作系统之上,管理计算机资源和网络通讯 ● 连接两个独立应用 程序或独立系统的软件,即使它们具有不同的接口 ● 通过中间件,应用 程序可以工作于多平台或OS 环境 ● Mail System不是中间件 **作用**：1.屏蔽异构性：异构性表现在计算机的软硬件差异,包括硬件 (CPU和指令集等,操作系统、数据库(不同存储和访问格式等
2.实现互操作：因为异构性,产生的结果是软件依赖于计算环境,使得 各种不同软件之间在不同平台之间不能移植,或者移植困难。而且,因 为网络协议和通信机制不同,这些系统不能有效相互集成
3.共性凝练和复用：软件应用领域越来越多,相同领域的应用系统之间 许多基础功能和结构是有相似性的。通过中间件提供简单、一致、集 成的开发和运行环境,简化分布式系统的设计、编程和管理 意义：缩短开发周期、节约应用程序开发成本、降低运行成本、降低 故障率、改善决策、应用系统群集/集成、减少软件维护、提高质量 、改进技术、提高产品吸引力 
**分类**: 1.应用服务类中间件: 为应用系统提供一个综合的计算环境和支 撑平台,包括对象请求代理~、事务监控交易~、Java应用服务器~等
2.应用集成类中间件: 提供各种不同网络应用系统之间的消息通信、 服务集成和数据集成的功能, 如消息中间件、企业集成EAI、企业服务 总线以及相配套的适配器。
3.业务架构类中间件: 除了可以将底层共性技术的特征抽象到中间件,还可以将业务共性抽象至中间件,形成应用模式,如业务流程等
**4+1视图模型** 用例视图：描述系统的典型场景与功能 逻辑~：系统的抽象概念与功能(类、接口等)类图,协作图,时序图等； 开发~：系统中的子系统,模块,文件,资源的关系,组件图、包图等； 进程~：系统的进程及其之间的通信协作关系,活动图,时序图等；物理~：系统如何被安装,部署,配置在分布式的环境下,部署图
### 软件架构风格 
**定义**：描述用于以组织一类软件系统的惯用模式,反映了领域中众 接收按行排列的数据, 重复地把第一个词删除,然后接到行末,把所有行 多系统所共有的结构和语义特性,并指导如何将各个模块和子系统 的各种移位结果按照字母表顺序输出 有效地组织成一个完整的系统。定义一些构件和连接件类型,施加 主程序-子过程风格 一组约束描述组合方式 
**分类** 数据流风格：批处理；管道/过滤器；过程控制；
调用/返回风格：主程序/子程序；⾯向对象；分层结构
独立构件风格：事件系统；
虚拟机风格：解释器；基于规则的系统；
以数据为中心的风格：仓库；⿊板；
其他架构风格：MVC；P2P；Grid；SOA
#### KWIC案例
接收按行排列的数据, 重复地把第一个词删除,然后接到行末,把所有行的各种移位结果按照字母表顺序输出
#### 面向对象风格
系统 被看作对象的集合, 每个对象都有一个它自己的操作集合。数据及作用在数据上的操作被封装成抽象数据类型(对象)，可以做到信息隐藏,内部的设计决策被封装
**构件**：类和对象 
**连接件**：对象之间通过函数与过程调用实现交互
**特性**: ●封装：限制对某些信息的访问 ● 交互：通过过程调用或类似的协议 ● 多态：在运行时选择具体的操作 ● 继承：对共享的功能保持唯一的接口 ● 动态绑定：运行时决定实际调用的操作
复用和维护
**优点**：复用和维护；反映现实世界；容易分解一个系统
**缺点**：管理⼤量的对象；必须知道对象的身份标识；继承引起复杂度,关键系统中慎用
**应用在KWIC**: 数据不再被构件直接共享,而是被封装在了Object中, 每个对象提供了一个接口,允许其他对象通 过该接口调用对该对象内封装的数据的操作
**优点**: 修改不影响其他构件, 依赖性降低, 复用性提高
**缺点**:不适合功能的扩展(要么修改已有的, 要么新增模块)
#### 主程序-子过程风格
**构件**：主程序,子程序 
**连接器**：调用-返回机制 
**拓扑结构**：层次化结构
**过程函数调用机制**：硬件基础(寄存器、跳转指令、栈操作指令) 实现机制
栈是一种先进后出的数据结构。即先进栈的数据后出，而后进栈的数据先出。
函数调用实际上是进行程序的跳转，在转去执行函数之前，应把现场保护起来(栈、寄存器)，以备函数执行完毕还回到刚才跳 转的地方，接着执行后继程序。
**非结构化程序**：所有的程序代码均包含在一个主程序⽂件中
**缺陷**：逻辑不清；无法复用；难以与其他代码合并；难于修改;难以测试特定部分的代码
**结构化程序**：逐层分解 ● 基于“定义-使用”关系 ● 用过程调用作为交互机制 ● 主程序的正确性依赖于它所调用的⼦程序的正确性
**本质**: 将大系统分解为若干模块(模块化),主程序调用这些模块实现完整的系统功能。
主子过程的**优点**：已被证明是成功的设计方法,可以被用于较大程序
**缺点**：代码太多,表现不好；程序太大,开发太慢,测试越来越困难
**分解成模块的四大原则**：
模块独立性：高聚合、低耦合 模块规模适中性：过大分解不充分难理解; 过小开销大接口复杂, 模块复用性：高扇入+低扇出 ；作用域与控制域适当性：作用域要包含在控制域之中
 - C的控制域包括C自己和C下属(调用)的模块
 - 作用域：一个模块里有判断语句,这个语句会影响多个模块,多个模块依赖于这个判定条件,那么影响的范围就是作用域
 - C控制域是CEF,作用域CEFD,作用域>控制域,一旦C做了修改,你就要去找D的位置,因为你的修改可能影响D,一旦修改了你还要去找D在哪(因为它不受你控制),会带来负面的影响,这是一种耦合性,会对维护带来很大的麻烦
**应用在KWIC**: 1.分为四个基本功能：输入、移位、排序、输出
2.主程序按次序调用这四个模块 3.通过共享的数据存储、使用无约束的读-写协议在模块之间进行 数据交换)
#### 数据流风格
**处理操作**：数据到达即被激活,无数据时不工作
**特征**：数据的可用性决定着处理计算单元是否执行；
**系统结构**：数据在各处理之间的有序移动；在纯数据流系统中,处理操作之间除了数据交换,没有任何其他的交互
**构件**：数据处理, 构件接口：输入端口和输出端口,从输入端口读取数据,向输出端⼝写入数据,计
算模型：从输入端口读数,经过计算/处理,然后写到输出端口, 连接件：数据流 (单向、通常是异步、有缓冲 ● 接口角色：reader和writer ● 计算模型: 把数据从一个处理的输出端口传送到另一个处理的输入端口)
**拓扑结构**：任意拓扑结构的图

  管道-过滤器风格

适用场景：数据源源不断的产生,系统需要对这些数据进行若⼲处理。解决方案：把系统分解为⼏个顺序的处理步骤,这些步骤之间通过数据流连接,一个步骤的输出是另一个步骤的输入；每个处理步骤由一个过滤器实现；处理步骤之间的数据传输由管道负责。每个处理步骤(过滤器)都有一组输入和输出,过滤器从管道中读取 输入的数据流,经过内部处理,然后产生输出数据流并写入管道中 构件：过滤器, 处理数据流 连接件：管道,连接一个源和一个目的过滤器。连接器定义了数据流的图, 形成拓扑结构

过滤器 目标：将源数据递增的变换成目标数据

数据流变换的方式：增加丰富数据；通过浓缩和删减精炼数据；改变数据表现方式转化数据；分解为多个流；数据流合并为一个

读取与处理数据流方式: 递增的读取和消费数据: 数据到来时便处理,不是收集完然后处理,即在输入被完全消费之前输出就产⽣了

其他特征：无上下文信息；不保留状态；对上下游的其他过滤器无任何了解