**1. 从 Linux 0.11 现在的机制看，它的系统调用最多能传递几个参数？**

  

从 **Linux 0.11** 当前的机制来看，系统调用最多能传递 **三个参数**。

原因是：

• 系统调用使用寄存器传递参数。

• 其中 **eax** 寄存器用于传递系统调用号，而 **ebx、ecx 和 edx** 三个寄存器用于传递参数。

• 内核中仅定义了 _syscall1、_syscall2 和 _syscall3 宏，分别支持传递 1、2 和 3 个参数。

  

因此，Linux 0.11 的系统调用最多只能传递 **三个参数**。

  

**2. 你能想出办法来扩大这个限制吗？**

  

可以通过以下方法扩大系统调用的参数传递限制：

  

**方法：将多个参数打包到一个结构体中，并通过一个指针传递结构体首地址。**

• 将需要传递的多个参数封装到一个结构体中。

• 在系统调用时，只需将结构体的**首地址**传递给内核，这样就能间接传递任意数量的参数。

• 在内核中，通过这个地址访问结构体中的各个参数，完成数据交互。

• 结构体在用户态定义，内核通过访问用户空间数据（例如使用 get_fs_* 系列函数）获取具体参数值。

  

**示例**：

假设要传递 5 个参数，定义结构体：

  

struct foo_args {

    int arg1;

    int arg2;

    int arg3;

    int arg4;

    int arg5;

};

  

系统调用时只需传递 struct foo_args *args。

  

**3. 用文字简要描述向 Linux 0.11 添加一个系统调用 foo() 的步骤。**

  

以下是向 **Linux 0.11** 添加新系统调用 foo() 的步骤：

1. **修改系统调用表**：

在 include/linux/sys.h 文件中，声明新系统调用的函数：

  

extern int sys_foo();

  

在 sys_call_table 中添加 sys_foo：

  

int (*sys_call_table[]) = {

    ...

    sys_foo,    /* 添加新系统调用 */

};

  

  

2. **定义系统调用号**：

在 include/unistd.h 中，定义新系统调用号：

  

#define __NR_foo 72   /* 假设当前最大系统调用号是 71 */

  

  

3. **更新系统调用数量**：

在 kernel/system_call.s 文件中，将系统调用的总数 nr_system_calls 增加 1：

  

nr_system_calls = 73  /* 原来是 72，现在增加 1 */

  

  

4. **实现系统调用函数**：

在 kernel 目录下，创建一个新的 foo.c 文件，编写系统调用的具体实现：

  

#include <linux/unistd.h>

#include <asm/segment.h>  /* 用于用户态数据访问 */

  

int sys_foo(void) {

    printk("Hello, this is sys_foo!\n");

    return 0;  /* 返回值 */

}

  

  

5. **修改 Makefile**：

将新文件 foo.c 添加到内核编译系统中，修改 kernel/Makefile：

  

obj-y += foo.o

  

  

6. **提供用户态接口**：

在用户程序中，使用 `_syscallN` 宏调用新系统调用。在用户代码中定义接口：

  
```
#define __LIBRARY__

#include <unistd.h>

  

_syscall0(int, foo);  /* 定义一个不带参数的系统调用 */

  

int main() {

    foo();  /* 调用新系统调用 */

    return 0;

}

  
```


  

7. **重新编译内核并测试**：

• 重新编译内核，将新系统调用编译进内核。

• 启动新内核，运行用户程序验证 foo() 系统调用是否正常工作。

  

**总结**

1. **系统调用参数限制**：最多传递 **三个参数**。

2. **扩大限制方法**：使用结构体封装参数，通过指针传递结构体首地址。

3. **添加新系统调用步骤**：修改系统调用表、定义系统调用号、实现系统调用函数、更新 Makefile 并提供用户接口。