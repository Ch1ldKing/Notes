*本文请配合大纲食用*

最近很多同学都在吐槽一门课：软件构造。🤬有的同学说这是一门“文科课”：“这么多概念，不是设计理念，就是教我怎么写注释，跟politics一样教条”

这位同学说的也没什么错，确实是学了这些东西和概念，什么不变量啊，一揽子设计模式啊，什么测试策略和规约，确实很多概念。但问题在于，它并不教条。

# “软件构造”是一种思想
❓为什么这么讲
 1. 首先，这是一门我认为最接近上班的**实际生产**的课程，实际上，这是一门未来工作的“减负课”，旨在提出一系列方法来参考我们的生产活动，也就是代码。
 2. 其次，这门课其实是在帮你从学生向程序员进行**思想上的改变**：我们写代码不再是写一段程序、写一个功能、写一个算法，而是要把砖块筑成大厦。在思考一个程序的时候，我们不再会思考“先定义一个变量，再通过循环遍历，最后返回值”，而是思考“为了这个功能，我需要设计哪些实体类，同时我需要测试、设计 RI，设计父类子类”。显然，我们的视角已经上升了一到两个层次。
 3. 这是一门“**经验学科**”，前人总结了一系列方法，能够规范代码的行为，并通过这门课把这些方法喂到我们嘴里。如果某一天一群“有素质”的程序员写了一个程序，你并不会觉得有什么。但一个没学过“软件构造”的人进来了，一切功能都能跑，但你改的时候，就是头疼的要命。你会不会破口大骂呢
 4. 当一大堆理念传授给你的时候，往往你学会的就不是方法和理念，而是理念背后的**思想**。我敢打赌，即使你课都没好好听，在借鉴（copy）实验作业的过程中，熬夜看 PPT 的时候，也有一种设计思想润物细无声般进入了你的大脑：
	+ 测试优先：这能保证我的程序及时发现错误，减少后期成本
	+ 写好测试策略和规约等：这能保证我和其他程序员不用读复杂的代码，也能知道这段代码干了什么
	+ 设计好 ADT：这能将现实中的实体引入到虚拟世界，未来的工作就是基于现实优化的网络世界。同时，做好防护（AF，RI），能帮你迅速找到许多 bug，好事一桩
	+ 做好 AF 、RI和表示泄露处理：这能保证我的服务端和客户端之间不需要“知根知底”就能进行交流与开发。要知道，当你把一切都告诉别人，别人往往不是帮你，而是害你
	+ OOP 的理念：我更愿意称其一种“模块化”的理念。当一个复杂的程序，可以被拆解为一个一个类，并且通过 Override、Overload等实现类之间的继承，你通过抽象出来的接口，最终拼接成一个完整的程序。而当你维护时，发现一切已经在最初设计时就铺平道路，听着就爽
	+ 复用性、拓展性、健壮性、正确性：如果一个程序满足这四点，那么它就是一个比较完美的程序。从开发到运维，真正的全过程生命周期，都被包含在内。所以这就是一个程序需要满足的东西，简单而纯粹
因此，这些才是软件构造所学的。即使你忘记了具体有哪些设计方法，忘记了 `@Overload`怎么用，忘记了 Javadoc 怎么写，但这些思想是不会消散的

# 多年以后，你可能需要回顾的东西
本文章显然不是为了考试，而是在说“我学了什么有用的”。主要基于上面提到的思想进行拓展：
## 测试优先
### “测”什么
![image.png](https://s2.loli.net/2024/05/25/bOkzoa51PhlgEtR.png)
### 怎么“测”
🧐**好的测试？**
1. 能发现错误
2. 不冗余
3. 有最佳特性
4. 别太复杂也别太简单
首先，要明确单元测试是需要根据 spec 进行的，这个后面会说
因此，我们需要一些测试的方法：
#### 黑盒测试
##### 等价类划分
根据spec去分析等价类，从不同角度：正负、奇偶、整数非整数
##### 边界值分析
边界上的值：比边界略大略小、无限大无限小、0
##### 如何设计
每个维度被覆盖一次即可
![image.png](https://s2.loli.net/2024/05/25/BjOlEJysPecaoiZ.png)
#### 白盒测试
考虑内部实现细节，根据程序代码运行时可能走过的所有路径进行测试，比如进入或不进入循环/if，是否抛出异常，为每种路径至少覆盖一次
举个例子：