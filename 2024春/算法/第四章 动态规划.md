# 动态规划原理
## 条件
满足优化子结构和重叠子问题
## 步骤
![[Pasted image 20240514005000.png]]
# 矩阵连乘算法
1. 分析优化解结构，原问题最优解包含子问题最优解![[Pasted image 20240514005054.png]]
2. 递归最优解代价，代价方程：![[Pasted image 20240514005208.png]]
3. 计算优化解代价，并同时保存构造最优解的信息
   ![[Pasted image 20240514005324.png]]
   逐个计算，并且在计算中保留下来用的k是几能得到最小的m[i,j]。将k的值存入s[i,j]中（加括号的位置）
   4. 构造最优解
      根据s[i,j]递归的构造![[Pasted image 20240514010649.png]]
      
      
#### 伪代码
![[Pasted image 20240514005627.png]]
第一层，是有多少个矩阵
第二层，是每个矩阵有几对需要判断。比如有5个矩阵，则A1需要和2345，A2需要和345
第三层，是计算每个的k。因为有很多种k，得出的所需计算次数不同，通过比较次数得到最优的k
#### 时间复杂度
由于三层循环，所以$O(n^3)$
空间是二维，$O(n^2)$
# 最长公共子序列
1. 分析优化解结构
   ![[Pasted image 20240514130603.png]]
   第一条：如果XY的最后一个字符相同，则其之前的部分，也就是$X_{m-1}Y_{n-1}$的公共子序列是$Z_{k-1}$，然后加上最后一个相同的字符就是当前的公共子序列LCS:Zk了
   第二条（二三一样）：如果最后一个字符不一样，那就把最后一个字符删了，这个删了的字符一定不在公共子序列里面。但是需要注意的是，删X和删Y，得到的情况不一定一样。![[Pasted image 20240514132114.png]]
   子问题重叠性：![[Pasted image 20240514132659.png]]
1. 递归最优解代价方程
   ![[Pasted image 20240514132325.png]]
3. 计算最优解代价
   计算长度同时存储箭头方向
   ![[Pasted image 20240514133011.png]]
   先把第0行和第0列置0，然后从第一行开始找，需要遍历所有的格子，如果最后一个字符相同，就存↖︎，并且新格子是原格子+1；如果不相同，就比较它上面和左面的数，哪个大继承哪个，并且选择存↑或者←
4. 构造最优解
   按照B[i,j]构造解，从右下角到左上角递归构造。意思是比如需要构造右下角的格子需要构造它的前一个，也就是上一行i-1的那个，构造它又需要构造↖︎的那个...依次类推
#### 伪代码
![[Pasted image 20240514133041.png]]
   ![[Pasted image 20240514133902.png]]
#### 复杂度
时间：计算每个格子是O(mn)，构造的时候是O(m+n)
空间：O(mn)
# 01背包
![[Pasted image 20240514153556.png]]
总重量小于等于C时，价值最大
1. 分析优化解结构
   ![[Pasted image 20240514153746.png]]
   证明优化解的子问题是优化解：先假设子问题不是优化解，则别人z是优化解。对这个z进行条件的式子书写，然后这个z的子问题要比y子问题的价值大。两边同时加v1y1发现矛盾，得证
   子问题重复性：
   后续背包存放用到之前计算过的最大价值
2. 代价方程
   ![[Pasted image 20240514153403.png]]
   * 第一种：放不下新加的i物品，那就继承之前的状态
   * 第二种：背包够放i物品，那就考虑一下带不带i，然后比较这两种的价值
     * 第一种：不放，那就继承刚才的价值
     * 第二种：放，放了i之后背包容量还有j-w[i]，则这些容量放别的物品的最大价值是多少呢？是i-1(意为除了i物品的情况)在j-w[i]的背包中的最大价值，之前已经计算过了，即v\[i-1]\[j-w\[i]]。然后再加上v[i]    
   然后，构建代价方程
   ![[Pasted image 20240514154907.png]]
3. 自底向上计算代价
   先初始化0行0列，然后循环，先逐行，再逐列
4. 构造最优解
   考虑背包容量为C（即最大值）的情况，从最后一个开始遍历，形成x[i]数组，如果i行价值比i-1行大，那就是放i了，i放了那就x[i]=1。然后j要减去这个物品的重量，再判断，一直到i=1
#### 伪代码
![[Pasted image 20240514162211.png]]
![[Pasted image 20240514162304.png]]
#### 复杂性
时间：两层for O(Cn)，构造解需要O(n)。因此O(Cn)
空间：二维 O(Cn)
# 最优二分搜索树
要么找到k节点，要么找到d伪节点
![[Pasted image 20240514171813.png]]
   
深度+1是因为根节点作第0层，搜索次数实际为深度+1
1. 优化解结构
   ![[Pasted image 20240514192916.png]]
2. 递归方程
   ![[Pasted image 20240514193107.png]]
3. 求解代价
   首先，按递归式计算搜索代价，同时记录最优策略。计算用公式计算即可，再用Root[i]/[j]表示当前ki和kj的根（键）
4. 根据Root构造最优解
#### 伪代码
![[Pasted image 20240514194422.png]]
第一层是树的大小，从已知最小的树（只包含一个键开始），i是子树起始键的位置，而r是选择不同的键作为根节点。比如选k1当，选k2当，选k3当算出来的代价是不一样的，要挑最小的
![[Pasted image 20240514200910.png]]

