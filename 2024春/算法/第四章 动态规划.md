# 动态规划原理
## 条件
满足优化子结构和重叠子问题
## 步骤
![[Pasted image 20240514005000.png]]
# 矩阵连乘算法
1. 分析优化解结构，原问题最优解包含子问题最优解![[Pasted image 20240514005054.png]]
2. 递归最优解代价，代价方程：![[Pasted image 20240514005208.png]]
3. 计算优化解代价，并同时保存构造最优解的信息
   ![[Pasted image 20240514005324.png]]
   逐个计算，并且在计算中保留下来用的k是几能得到最小的m[i,j]。将k的值存入s[i,j]中（加括号的位置）
   4. 构造最优解
      根据s[i,j]递归的构造![[Pasted image 20240514010649.png]]
      
      
#### 伪代码
![[Pasted image 20240514005627.png]]
第一层，是有多少个矩阵
第二层，是每个矩阵有几对需要判断。比如有5个矩阵，则A1需要和2345，A2需要和345
第三层，是计算每个的k。因为有很多种k，得出的所需计算次数不同，通过比较次数得到最优的k
#### 时间复杂度
由于三层循环，所以$O(n^3)$
空间是二维，$O(n^2)$
# 最长公共子序列
1. 分析优化解结构
   ![[Pasted image 20240514130603.png]]
   第一条：如果XY的最后一个字符相同，则其之前的部分，也就是$X_{m-1}Y_{n-1}$的公共子序列是$Z_{k-1}$，然后加上最后一个相同的字符就是当前的公共子序列LCS:Zk了
   第二条（二三一样）：如果最后一个字符不一样，那就把最后一个字符删了，这个删了的字符一定不在公共子序列里面。但是需要注意的是，删X和删Y，得到的情况不一定一样。![[Pasted image 20240514132114.png]]
   子问题重叠性：![[Pasted image 20240514132659.png]]
1. 递归最优解代价方程
   ![[Pasted image 20240514132325.png]]
3. 计算最优解代价
   从右下角往左上角计算，计算长度同时存储箭头方向
   ![[Pasted image 20240514133011.png]]
   先把第0行和第0列置0，然后从第一行开始找，如果最后一个字符相同，就存↖︎；如果不相同，就比较它上面和z
#### 伪代码
![[Pasted image 20240514133041.png]]
   