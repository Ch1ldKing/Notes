 ![[Pasted image 20240516233004.png]]
# 爬山法
局部择优
如果当前方案最优，那就返回。在附近也找新方案，如果有更好的就换
#### 算法
![[Pasted image 20240516234246.png]]
# Best-First
在爬山法的基础上，采用最小堆来存储节点。爬山法只在当前节点的临近节点进行搜索，而最佳优先采用堆中最小的节点，且每次考虑的时候会保留堆中的节点，而不是不管别的了
![[Pasted image 20240516234547.png]]
![[Pasted image 20240516235244.png]]
# 分支界限法
重点在于剪枝。先找一个界限，如果后续节点不可能比界限（当前最优解）更优，就剪枝。而产生分支的策略就是爬山或者BTS
![[Pasted image 20240517095526.png]]
采用优先队列存储所有的节点。
# 旅行商问题
大概就是把图换成矩阵，然后减数，减的数加起来就是最小代价（代价下界）
然后找0的地方，用行最小+列最小，能找到使下界增加最大的边，然后构造左右子树，一个包含一个不包含。
然后递归构造。对于左子树，把刚刚用过的边的行列删除后，再进行减数找0操作；对于右子树，把刚刚的边环卫无穷大
# A*
代价函数来限制优化解。其实就是Best-First的评价函数。这个函数的值为到当前节点的代价+预估到目标节点的代价。这些节点按照函数的值在优先队列里