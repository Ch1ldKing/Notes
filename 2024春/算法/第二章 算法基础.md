# 分析算法
## RAM模型
### 特征
1. 基本操作都是常数时间
2. 只有一个处理器
3. 访问任何内存单元的时间一致，不受位置影响，因此也叫随机访问存储器
4. 有无限量的存储空间，因此空间复杂度不受内存大小限制
### 应用

1. 忽略一些没用的东西
2. 通过基本操作的数量来计算时间
# 函数
## 同阶函数的集合

![[Pasted image 20240513191925.png]]

证明：找任意的c1,c2,n0
![[Pasted image 20240513192217.png]]

## 低阶函数的集合

![[Pasted image 20240513193445.png]]

和$\Theta$的关系
![[Pasted image 20240513193515.png]]

## 高阶函数集合

![[Pasted image 20240513195043.png]]

## 三种标记关系

注意，上界是低阶，下界是高阶
![[Pasted image 20240513195133.png]]

## 严格低阶

![[Pasted image 20240513201535.png]]

证明：找n0，符合c>0
![[Pasted image 20240513201827.png]]

![[Pasted image 20240513201852.png]]

o一定是比g(n)阶数低的。所以满足
![[Pasted image 20240513203424.png]]

## 严格高阶

![[Pasted image 20240513203613.png]]

# 运行时间
最坏和平均情况
$$\Theta(n^2)$$
# 分治法
二分成可以直接操作的步骤，然后返回
## 归并排序
时间复杂度
![[Pasted image 20240422223133.png]]
化成递归树
![[Pasted image 20240422223237.png]]
树的高度是$$log(n)即(log_2(n))$$
# Master定理
Master定理（Master Theorem）是一种用于分析具有递归性质的算法时间复杂度的工具，特别是那些可以被分解为多个较小子问题的分治算法。使用Master定理可以快速得出一个递归关系式的解。递归算法通常可以表示为：

𝑇(𝑛)=𝑎⋅𝑇(𝑛𝑏)+𝑓(𝑛)

其中：

- 𝑛n 是问题的大小。
- 𝑎≥1a≥1 表示递归每次生成的子问题数量。
- 𝑏>1b>1 是每次递归中问题大小的缩小比例。
- 𝑓(𝑛)f(n) 是除了递归调用之外的算法其他部分的时间复杂度。

Master定理将𝑓(𝑛)f(n)与𝑛log⁡𝑏𝑎nlogb​a进行比较，以确定𝑇(𝑛)T(n)的渐进行为。定理分为以下三种情况：

![[Pasted image 20240516105228.png]]𝑇(𝑛)=Θ(𝑓(𝑛))T(n)=Θ(f(n))。
    

### 使用Master定理的步骤：

1. **识别递归关系式中的 𝑎, 𝑏, 和 𝑓(𝑛)。**
2. **计算 log⁡𝑏𝑎。**
3. **比较 𝑓(𝑛) 与 𝑛log⁡𝑏𝑎，确定属于哪种情况。**
4. **应用相应的情况得出 𝑇(𝑛)T(n) 的时间复杂度。**

### 例子：

假设一个递归算法的时间复杂度为： 𝑇(𝑛)=2𝑇(𝑛2)+𝑛T(n)=2T(2n​)+n 其中，𝑎=2a=2, 𝑏=2b=2, 𝑓(𝑛)=𝑛f(n)=n。

- 计算 log⁡𝑏𝑎=log⁡22=1logb​a=log2​2=1。
- 因为 𝑓(𝑛)=𝑛=𝑛1=𝑛log⁡22f(n)=n=n1=nlog2​2，这符合Master定理的第二种情况，其中 𝑘=0k=0。
- 所以，𝑇(𝑛)=Θ(𝑛log⁡𝑛)T(n)=Θ(nlogn)。

通过这种方式，Master定理能够快速准确地帮助你确定分治递归算法的时间复杂度。