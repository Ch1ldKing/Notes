# 分析算法
## RAM模型
### 特征
1. 基本操作都是常数时间
2. 只有一个处理器
3. 访问任何内存单元的时间一致，不受位置影响，因此也叫随机访问存储器
4. 有无限量的存储空间，因此空间复杂度不受内存大小限制
### 应用

1. 忽略一些没用的东西
2. 通过基本操作的数量来计算时间
# 函数
## 同阶函数的集合

![[Pasted image 20240513191925.png]]

证明：找任意的c1,c2,n0
![[Pasted image 20240513192217.png]]

## 高阶函数的集合

![[Pasted image 20240513193445.png]]

和$\Theta$的关系
![[Pasted image 20240513193515.png]]

## 高阶函数集合


# 运行时间
最坏和平均情况
$$\Theta(n^2)$$
# 分治法
二分成可以直接操作的步骤，然后返回
## 归并排序
时间复杂度
![[Pasted image 20240422223133.png]]
化成递归树
![[Pasted image 20240422223237.png]]
树的高度是$$log(n)即(log_2(n))$$
# Master定理
Master定理（Master Theorem）是一种用于分析具有递归性质的算法时间复杂度的工具，特别是那些可以被分解为多个较小子问题的分治算法。使用Master定理可以快速得出一个递归关系式的解。递归算法通常可以表示为：

𝑇(𝑛)=𝑎⋅𝑇(𝑛𝑏)+𝑓(𝑛)T(n)=a⋅T(bn​)+f(n)

其中：

- 𝑛n 是问题的大小。
- 𝑎≥1a≥1 表示递归每次生成的子问题数量。
- 𝑏>1b>1 是每次递归中问题大小的缩小比例。
- 𝑓(𝑛)f(n) 是除了递归调用之外的算法其他部分的时间复杂度。

Master定理将𝑓(𝑛)f(n)与𝑛log⁡𝑏𝑎nlogb​a进行比较，以确定𝑇(𝑛)T(n)的渐进行为。定理分为以下三种情况：

1. **如果 𝑓(𝑛)=𝑂(𝑛log⁡𝑏𝑎−𝜖)f(n)=O(nlogb​a−ϵ) 对于某个常数 𝜖>0ϵ>0：**  
    则 𝑇(𝑛)=Θ(𝑛log⁡𝑏𝑎)T(n)=Θ(nlogb​a)。
    
2. **如果 𝑓(𝑛)=Θ(𝑛log⁡𝑏𝑎log⁡𝑘𝑛)f(n)=Θ(nlogb​alogkn) 对于某个常数 𝑘≥0k≥0：**  
    则 𝑇(𝑛)=Θ(𝑛log⁡𝑏𝑎log⁡𝑘+1𝑛)T(n)=Θ(nlogb​alogk+1n)。
    
3. **如果 𝑓(𝑛)=Ω(𝑛log⁡𝑏𝑎+𝜖)f(n)=Ω(nlogb​a+ϵ) 对于某个常数 𝜖>0ϵ>0，且 𝑎𝑓(𝑛/𝑏)≤𝑐𝑓(𝑛)af(n/b)≤cf(n) 对于某个常数 𝑐<1c<1 和所有充分大的 𝑛n：**  
    则 𝑇(𝑛)=Θ(𝑓(𝑛))T(n)=Θ(f(n))。
    

### 使用Master定理的步骤：

1. **识别递归关系式中的 𝑎a, 𝑏b, 和 𝑓(𝑛)f(n)。**
2. **计算 log⁡𝑏𝑎logb​a。**
3. **比较 𝑓(𝑛)f(n) 与 𝑛log⁡𝑏𝑎nlogb​a，确定属于哪种情况。**
4. **应用相应的情况得出 𝑇(𝑛)T(n) 的时间复杂度。**

### 例子：

假设一个递归算法的时间复杂度为： 𝑇(𝑛)=2𝑇(𝑛2)+𝑛T(n)=2T(2n​)+n 其中，𝑎=2a=2, 𝑏=2b=2, 𝑓(𝑛)=𝑛f(n)=n。

- 计算 log⁡𝑏𝑎=log⁡22=1logb​a=log2​2=1。
- 因为 𝑓(𝑛)=𝑛=𝑛1=𝑛log⁡22f(n)=n=n1=nlog2​2，这符合Master定理的第二种情况，其中 𝑘=0k=0。
- 所以，𝑇(𝑛)=Θ(𝑛log⁡𝑛)T(n)=Θ(nlogn)。

通过这种方式，Master定理能够快速准确地帮助你确定分治递归算法的时间复杂度。