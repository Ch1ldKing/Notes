![image.png](https://s2.loli.net/2024/06/12/2Xmj4AR7oylzEIu.png)
![image.png](https://s2.loli.net/2024/06/12/z3Ny6DXf5ITxsdr.png)
2. 在主存中读写传输数据首先要传输地址
3. 中断是指CPU执行指令以外的事件
4. 对外部中断请求的检测在执行后，下一条之前
5. 微操作对应微命令组成微指令组成微程序
6. 字段间接编码，意为某个字段的译码输出要依靠另外某个字段的输入
7. IR 和 FR 会连接到 CU 的输入端
8. SF 表示正负，OF 有逻辑表达式
9. 指令字长一般为字节整数倍
10. 一次读或写是读写时间，连续两次独立读或写是存取周期
11. IR,MAR,MDR 是 CPU 内部工作寄存器，对程序员透明
12. 间址周期是为了取操作数的有效地址，而 MDR 是数据寄存器，在间址周期结束后，MDR 中存在的是操作数的有效地址
13. 转移指令也是把PC覆盖，因此指令永远从PC中读出，PC存的是指令的地址，PC决定指令执行顺序
14. 条件转移指令，需要的条件来自标志寄存器
15. 控制器有PC,IR,Mar,MDR,指令译码器，时序电路，微操作信号发生器
16. RISC 一定采用流水，CISC 也常常采用流水技术，RISC 比较精简，兼容性差，CPU 通用寄存器多，指令功能不强
17. 寄存器间接寻址（R）表示寄存器R中存的是有效地址。存储器简介寻址（200）表示200中存的是有效地址。寄存器寻址R表示R中的内容就是操作数
18. 程序计数器存的是下一条指令的地址，存在存储器里，所以字长等于存储器字长
19. 立即寻址操作数在指令里
20. 间接寻址存的也是主存地址。寄存器寻址存的是寄存器地址，寄存器个数少。变址寻址中存的是形式地址
21. 转移指令
![image.png](https://s2.loli.net/2024/06/12/3A5QKTj7usVmrnO.png)
21. 扩展操作码是为了保持指令字长不变，操作码长度随地址长度减少而增加
22. 单地址指令不是固定长度的，可能因寻址方式不同而变化
23. 控制指令包括转移，调用，循环返回等。中断这种属于硬件实现，不属于指令系统
24. 程序控制类指令是改变程序执行的顺序
25. 控制信号是控制单元基于 ISA 生成的，不是ISA定义的
26. 给主存单元号，求对应Cache号时，要先块大小
27. Cache 采用回写时信息不一定与主存一致，只有被替换时写回主存
28. 空间局部性是一个内存位置被访问，则其附近的位置也很快会被引用，比如数组。时间局限性是一个内存地址被反复引用
29. 回写和全写是命中时用的
30. 计算Cache命中率CPU访内存的时间要加上访Cache时间
31. 如果浮点数基数为4，那么每次移需要移2位，则原本需要没有0，变为2位中不全为0
32. 阶码下溢不是溢出，而是负指数超过最小允许值，按机器零处理。尾数溢出可以通过右归来调整。指数上下溢看看是否到了全1或全0
33. 浮点运算中，0-规格化的最小正数之间的数为正下溢，0到最大负数之间是负下溢。也就是数轴上贴近0的数表示不了称为下溢
34. 无论是有符号数还是无符号数，2n位用来表示n位都不会溢出，因为2n可以完整地存储两个n位整数的乘积。如果转换为n位，则需要看n位与2n位表示的真值是否相同。对于无符号数，高 n位都是0的话就不溢出。如果是有符号数，则高n位与低n位的最高位都需要符合正负，否则溢出。因此，如果高n+1位的值全部相同，则表示不溢出
35. 有符号转化为无符号数，用模（也就是2的位数次方）减去这个数的绝对值
36. CF用于判断无符号数的运算是否溢出，最高位进位；不够减最高位借位，都是溢出，CF=1
37. 对于正负数相加，判断溢出看进位到最高位和进位到符号位的数是不是一样，也就是有没有进位
38. 对于正负数相加，判断溢出不能看符号位变化，必须之前是符号数相同的数
39. 逻辑移位，将数视为无符号数，左移时低位补0，右移时高位补0，若高位1移出，则溢出；算数移位，与符号相关，左移时低位补0，若前后符号改变则溢出，右移时高位补符号位，若低位的1移出，则丢失精度
40. 双符号位中，01是正溢出，10是负溢出
41. 模4补码只需要存储一个符号位，因为存储正确的数时，两个位相同
42. 对于补码，无论正负都是数值位越大，这个数越大（这个大指的是数轴上的大小）
43. 拓展补码，正数补0，负数补1
44. 补码和移码最高位相反，移码最高位不表示符号
### 微指令码点表

| 微指令地址    | 控制信号                              | 下地址      |
| -------- | --------------------------------- | -------- |
| 00000001 | `IR <- Mem[PC]`, `PC <- PC + 4`   | 00000010 |
| 00000010 | `A <- Reg[IR[25:21]]`             | 00000011 |
|          | `B <- Reg[IR[20:16]]`             |          |
|          | `Imm <- SignExtend(IR[15:0])`     |          |
| 00000011 | `ALUOut <- A op B`                | 00000100 |
| 00000100 | `Reg[IR[15:11]] <- ALUOut`        | FETCH    |
| 00000101 | `ALUOut <- A + Imm`               | 00000110 |
| 00000110 | `MDR <- Mem[ALUOut]` (LW)         | 00000111 |
|          | `Mem[ALUOut] <- B` (SW)           | FETCH    |
| 00000111 | `Reg[IR[20:16]] <- MDR` (LW)      | FETCH    |
| 00001000 | `if (A == B) PC <- PC + Imm << 2` | FETCH    |