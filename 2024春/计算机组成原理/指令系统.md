# 指令格式
操作码+地址码
![[Pasted image 20240423185858.png]]
## 指令字长
### 长度大小
通过与机器字长的关系分为<u>单字长指令</u>、<u>半字长指令</u>、<u>双字长指令</u>，同时导致指令时间开销不同
### 长度变化
1. 定长指令字结构：所有指令长度相等
2. 变长指令字结构：指令长度因功能而异，指令字长通常为字节的整数倍
## 不同机器代码
### 1. 零地址指令
只有操作码
1. 不需要操作数，停机、关中断等
2. 堆栈计算机，数从栈顶弹出
### 一地址指令
1. 单操作数指令，操作后存回原地址
2. 双操作数指令，另一个操作数在ACC中，操作后存放在ACC中
### 二地址指令
目的操作数和源操作数
需要访存四次，取指令1次，取两个操作数2次，存结果1次   
### 三地址指令
比二地址指令多一个结果操作数
### 四地址指令
多一个下一条要执行指令的地址
## 操作码指令格式
### 定长
指令字最高位分配固定的若干位表示操作码
### 扩展
其中一种安排
![[Pasted image 20240425003431.png]]
1111、11111110、111111111110留作拓展用，所以每个都有$2^4-1=15$条指令，除零指令无需拓展
⚠️ 短操作码不能是长操作码的前缀
### 指令操作类型
1. 数据传送
# 指令的寻址方式
## 指令寻址
寻找下一条要执行的指令的地址
### 顺序寻址方式
PC 程序计数器加 1
> PC **自增的大小**与编址方式、指令字长有关。现代计算机通常是按字节编址的，若指令字长为16位，则 PC自增为(PC)+2;若指令字长为32位，则PC自增为(PC)+4

### 跳跃寻址
**是否跳跃**：受状态寄存器的控制，不一定跳跃
**结果本质**：转移的结果是<mark style="background: #06FF06A6;">修改</mark> PC 的值，因为 CPU 是根据 PC 的内容去主存取指令的。这样下一条指令仍然通过 PC 给出
#### 跳跃方式
1. **绝对转移**：地址码直接给出转移目标地址
2. **相对转移**：地址码是相对于当前 <mark style="background: #06FF06A6;">PC</mark> 的值加上偏移量
## 数据寻址
表示操作数的地址
![[Pasted image 20240425111208.png]]
1. **寻址特征**：用来指明寻址方式
2. **形式地址(A)**：结合寻址方式可以计算出真实地址(EA)
### 数据寻址方式
