# 指令格式
操作码+地址码
![[Pasted image 20240423185858.png]]
## 指令字长
### 长度大小
通过与机器字长的关系分为<u>单字长指令</u>、<u>半字长指令</u>、<u>双字长指令</u>，同时导致指令时间开销不同
### 长度变化
1. 定长指令字结构：所有指令长度相等
2. 变长指令字结构：指令长度因功能而异，指令字长通常为字节的整数倍
## 不同机器代码
### 1. 零地址指令
只有操作码
1. 不需要操作数，停机、关中断等
2. 堆栈计算机，数从栈顶弹出
### 一地址指令
1. 单操作数指令，操作后存回原地址
2. 双操作数指令，另一个操作数在ACC中，操作后存放在ACC中
### 二地址指令
目的操作数和源操作数
需要访存四次，取指令1次，取两个操作数2次，存结果1次   
### 三地址指令
比二地址指令多一个结果操作数
### 四地址指令
多一个下一条要执行指令的地址
## 操作码指令格式
### 定长
指令字最高位分配固定的若干位表示操作码
### 扩展
其中一种安排
![[Pasted image 20240425003431.png]]
1111、11111110、111111111110留作拓展用，所以每个都有$2^4-1=15$条指令，除零指令无需拓展
⚠️ 短操作码不能是长操作码的前缀
### 指令操作类型
1. 数据传送
# 指令的寻址方式
## 指令寻址
寻找下一条要执行的指令的地址
### 顺序寻址方式
PC 程序计数器加 1
> PC **自增的大小**与编址方式、指令字长有关。现代计算机通常是按字节编址的，若指令字长为16位，则 PC自增为(PC)+2;若指令字长为32位，则PC自增为(PC)+4

### 跳跃寻址
**是否跳跃**：受状态寄存器的控制，不一定跳跃
**结果本质**：转移的结果是<mark style="background: #06FF06A6;">修改</mark> PC 的值，因为 CPU 是根据 PC 的内容去主存取指令的。这样下一条指令仍然通过 PC 给出
#### 跳跃寻址方式
1. **绝对转移**：地址码直接给出转移目标地址
2. **相对转移**：地址码是相对于当前 <mark style="background: #06FF06A6;">PC</mark> 的值加上偏移量
## 数据寻址
表示操作数的地址
![[Pasted image 20240425111208.png]]
1. **寻址特征**：用来指明寻址方式
2. **形式地址(A)**：结合寻址方式可以计算出真实地址(EA)
### 数据寻址方式

> [!问题] 问题
> 如果是计算出来的地址，立即寻址是直接计算出操作数的范围吗
> 怎么和寄存器有关系的
#### 1. 隐含寻址
单（一）地址指令隐含约定第二个操作数由 ACC 提供。
1. 优点：缩短指令字长
2. 缺点：增加存储操作数或隐含地址的硬件
#### 2. 立即寻址
地址字段不是地址，就是操作数本身，称**立即数**
1. 优点：指令执行速度最快
2. 缺点：限制了可寻找操作数（立即数）的范围
#### 3. 直接寻址
地址字段就是操作数的真实地址，EA=A
1. 优点：不需要专门计算，仅需访存一次
2. 缺点：指令操作数寻址范围被限制，并且操作数地址不容易更改，写死在里面了
#### 4. 间接寻址
地址字段是操作数地址的地址，也就是地址字段存的是主存地址 A，主存地址里存了操作数有效地址 EA
![[Pasted image 20240425143518.png]]
1. 优点：主存位数可用于存地址的位数大，这样范围更广；方便编制程序，完成子程序返回
2. 缺点：访存 2 次，执行速度慢，一般用寄存器间接寻址
#### 5. 寄存器寻址
直接寻址将操作数所在主存地址改为寄存器编号，指向所在寄存器
1. 优点：访问寄存器速度快
2. 缺点：寄存器贵数量有限
![[Pasted image 20240425150005.png]]
#### 6. 寄存器间接寻址
寄存器中存操作数所在主存地址
1. 优点：寻址范围大，减少访存次数
#### 7. 相对寻址
地址字段存的是相对地址，即PC+形式地址， EA =（PC）+ A
1. 优点：操作数的地址不是固定的，便于<mark style="background: #06FF06A6;">转移指令</mark>，便于程序浮动
>例：对于转移指令JMPA,若指令的地址为X,且占2B,则在取出该指令后，PC的值会增2,
>即(PC)=X+2,这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行
#### 8. 基址寻址


