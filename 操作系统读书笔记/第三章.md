### 3.1 内存管理概述

Intel 64和IA-32架构的内存管理分为两部分：段机制（Segmentation）和分页机制（Paging）。

- 段机制：通过将程序的代码、数据和栈划分为不同的段，确保多任务运行时彼此不会干扰。
- 分页机制：实现基于虚拟内存的系统，支持大于物理内存的线性地址空间，并提供隔离。
### 3.2 使用段机制

#### 3.2.1 基本平坦模型 (Flat Model)
- 在平坦模型中，操作系统和应用程序共享一个连续的、无分段的地址空间。
- 所有段的基地址设为0，段限值为4GB，使得分段机制不会因为内存越界而抛出异常。
#### 3.2.2 受保护的平坦模型 (Protected Flat Model)
 通过将段限值设置为物理内存实际存在的范围，对不存在的内存访问抛出#GP异常。增加复杂度后，可以定义用户态和内核态的代码和数据段来实现更高的隔离性。
#### 3.2.3 多段模型 (Multi-Segment Model)

- 每个程序或任务拥有自己的段描述符表和段。段可以是私有的或共享的。
- 硬件会强制执行访问检查，确保一个任务无法写入另一个任务的代码段或数据段。
- 该模型也支持访问权限检查和特权级别，保护操作系统免受应用程序的非法访问。
模型分类
1. 基本平坦模型：
    所有代码和数据段覆盖整个线性地址空间，基地址为0，限值为4GB。
2. 受保护平坦模型：
    段限值缩小到实际物理内存的大小，提供基本的硬件保护。
3. 多段模型：
    不同的程序或任务使用自己的段描述符和段寄存器，实现隔离和访问控制。
### 3.2.4 IA-32e模式中的分段机制

- 兼容模式 (Compatibility Mode)：分段机制与32位模式类似，保持向后兼容。
- 64位模式 (64-bit Mode)：分段机制被大部分禁用，创建平坦的64位线性地址空间。
    - FS和GS段寄存器仍可用于地址计算，有助于操作系统访问局部数据结构。
    - 段限值检查在64位模式下被禁用。
### 3.2.5 分页与分段的结合

- 分页机制可与任何分段模型（平坦模型或多段模型）结合使用。
- 分页机制将线性地址空间分为多个页面，并映射到物理地址空间中的页面。
- 页面级保护：支持基于页面的读写保护和用户/超级用户权限，补充或替代段保护。
### 3.3 物理地址空间 (Physical Address Space)

#### IA-32 架构的物理地址

- 32位地址空间：4GB (0x00000000 到 0xFFFFFFFF)，地址空间平坦且无分段，支持映射到读写存储器、只读存储器和内存映射I/O。
- 物理地址扩展 (PAE)：
    - 使用CR4控制寄存器中的第5位启用PAE，支持36位物理地址空间 (64GB)。
    - PSE-36：支持36位分页机制，Pentium III 处理器引入此功能。

 Intel 64 架构的物理地址
支持可变长度的物理地址范围，通过CPUID指令查询实际支持的物理地址位数。
### 3.4 逻辑地址和线性地址

IA-32 架构在保护模式下采用两级地址转换，从逻辑地址映射到线性地址，再从线性地址映射到物理地址。

1. 逻辑地址：由16位段选择符和32位偏移量组成。
    
    - 段选择符标识段，偏移量标识段内字节的相对位置。
2. 线性地址：逻辑地址转换后得到32位线性地址，覆盖整个线性地址空间 (0x00000000 到 0xFFFFFFFF)。
    
    - 如果不启用分页，线性地址直接映射到物理地址。
### 3.4.1 IA-32e模式下的逻辑地址转换

- 64位模式：段基址和偏移量扩展为64位，线性地址也为64位，需满足规范形式要求。
- 每个代码段描述符包含一个L位，决定该段是否执行64位代码。
### 3.4.2 段选择符 (Segment Selector)

段选择符结构如图所示：

| 位数   | 含义                        |
| ---- | ------------------------- |
| 15-3 | 段描述符索引，指向GDT或LDT中的描述符     |
| 2    | 表指示符 (TI)，0表示GDT，1表示LDT   |
| 1-0  | 请求特权级 (RPL)，范围0-3，0为最高特权级 |

GDT 的第一个条目保留为空段选择符 (null selector)，指向此条目的段寄存器不能用于访问内存，否则会触发 GP 异常。
### 3.4.3 段寄存器 (Segment Registers)

IA-32架构支持6个段寄存器，分别用于代码、数据、栈和额外数据访问：

|寄存器|用途|
|---|---|
|CS|代码段|
|SS|栈段|
|DS, ES, FS, GS|数据段|
每个段寄存器包括可见部分和隐藏部分，加载段选择符后，段描述符信息会缓存到隐藏部分，加速地址转换。修改段描述符表后，需要软件重新加载段寄存器。
### 3.4.4 IA-32e模式下的段加载指令

- 64位模式：ES、DS、SS寄存器的段基址被忽略，地址计算时段基址视为0。
- FS和GS段寄存器可用于线性地址计算：
    - 使用`WRMSR`指令将64位基址加载到FS.base或GS.base寄存器。
    - `SWAPGS`指令用于在GS寄存器和内核数据结构指针之间交换值。
### 3.4.5 段描述符 (Segment Descriptor)

段描述符存储于GDT或LDT中，描述段的大小、位置和访问权限，如下图所示：

| 字段          | 含义                    |
| ----------- | --------------------- |
| 段限值 (Limit) | 指定段大小                 |
| 段基址 (Base)  | 段在线性地址空间中的起始位置        |
| 类型 (Type)   | 指定段的访问类型，如代码段或数据段     |
| DPL         | 描述符特权级 (0-3)          |
| P位          | 段是否存在于内存中             |
| G位          | 段限值的单位 (字节或4KB)       |
| L位          | 64位代码段标志 (仅在IA-32e模式) |

### 3.4.5.1 代码段和数据段描述符类型

数据段类型的编码如下：

| **类型值** | **描述**     |
| ------- | ---------- |
| 0       | 只读数据段      |
| 2       | 可读写数据段     |
| 4       | 向下扩展只读数据段  |
| 6       | 向下扩展可读写数据段 |

代码段类型的编码如下：

|**类型值**|**描述**|
|---|---|
|8|仅执行代码段|
|10|可执行/读取代码段|
|12|一致性代码段 (Conforming)|

- 一致性代码段允许特权级较低的代码调用较高特权级的代码。
- 非一致性代码段则需通过**调用门**或**任务门**实现特权级转换。
### 总结

- **段机制**：实现了地址空间的结构化管理和访问控制，支持多任务和特权保护。
- **64位模式**：简化了段机制，主要用于特定用途（如FS和GS段）。
- **段加载与访问**：通过段寄存器和段描述符表实现快速地址转换和高效的内存管理。