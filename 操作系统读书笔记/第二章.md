# Preface
## IA-32架构与模式支持

- **IA-32架构**从Intel 386处理器系列开始，为**操作系统**和**系统开发软件**提供了全面支持。
- 这种支持包括多种**运行模式**：
    - **实模式（Real Mode）：** 最基础的模式，类似于老式的8086处理器，只能访问1MB内存。
    - **保护模式（Protected Mode）：** 允许访问更大的内存空间，并提供多种保护机制，用于多任务和进程隔离。
    - **虚拟8086模式（Virtual 8086 Mode）：** 在保护模式下模拟8086处理器的环境，用于运行旧的16位程序。
    - **系统管理模式（System Management Mode，SMM）：** 一种特殊模式，用于电源管理或硬件资源管理。

*这些属于遗留的模式，由于系统开发问题，他们在386之后的处理器上保留了下来*
##  Intel 64 架构及 IA-32e 模式
**Intel 64架构**扩展了IA-32架构，支持**64位环境**，并新增了一种模式：
- **IA-32e模式：** 用于64位程序开发的环境。在这个模式下，存在两种**子模式**：
    - **64位模式（64-bit Mode）：** 支持64位操作系统和应用程序。
    - **兼容模式（Compatibility Mode）：** 允许旧版（32位）的软件在64位操作系统中运行，与64位应用共存。

*该架构拓展原有架构，以支持64位的环境，并且新模式可以兼容老程序*

## 架构中共有的系统级功能
- **内存管理（Memory Management）：** 支持虚拟内存和内存保护。
- **软件模块保护（Protection of Software Modules）：** 通过权限和隔离机制保护进程。
- **多任务（Multitasking）：** 支持多个程序同时运行。
- **异常与中断处理（Exception and Interrupt Handling）：** 管理错误和硬件事件的响应。
- **多处理器支持（Multiprocessing）：** 支持多核或多处理器并行执行。
- **缓存管理（Cache Management）：** 提升性能的缓存优化机制。
- **硬件资源与电源管理（Hardware Resource and Power Management）：** 高效地管理硬件资源和电力消耗。
- **调试与性能监控（Debugging and Performance Monitoring）：** 协助开发者进行系统调试和性能优化。

*首先是最重要的内存机制，包括对内存的虚拟化，通过权限保护内存中进程，隔离进程不受干扰，优化缓存，并且可以对异常进程进行处理。其次是对多处理器的适配，以及可以监控系统性能与硬件资源*
## 模式切换
初始化流程：
通过**系统级指令**与**系统级寄存器**，可以实现模式的切换。通过**上电或复位（reset）** 进行切换**实地址模式**，可以继续通过软件切换到**保护模式**，再从保护模式切换到**IA-32e模式**。

# 2.1 系统架构概览
## 2.1.1 GDT与LDT
 在**保护模式**下，所有内存访问都需要通过**全局描述符表 (GDT)** 或 **局部描述符表 (LDT)** 进行。
 *通过段选择子->(索引GDT,LDT)->段描述符->(GDT,LDT存储)->基地址->(偏移量)->字节位置*
### 段描述符
- **GDT** 和 **LDT** 存储称为**段描述符 (Segment Descriptor)** 的条目。
-  每个段描述符包含：
    - **段的基地址 (Base Address)**：定义段的起始位置。
    - **访问权限 (Access Rights)**：控制对段的访问级别。
    - **段的类型 (Type)**：如代码段、数据段或堆栈段。
    - **使用信息 (Usage Information)**：记录段的用途和状态。
### 段选择子
- 每个段描述符对应一个**段选择子 (Segment Selector)**。
- **段选择子**的功能：
    1. 作为**GDT或LDT中的索引**，指向具体的段描述符（即段描述符在表中的偏移地址）。
    2. 包含一个**全局/局部标志位**，用于指定选择子是指向**GDT**还是**LDT**。
    3. 保存**访问权限信息**，控制段的访问。
### 访问内存字节
- 在访问段中的字节时，需要**段选择子和偏移量**：
    1. 段选择子提供对应段描述符的索引。
    2. 段描述符从**GDT或LDT**中读取，得到段在**线性地址空间**中的**基地址**。
    3. 使用偏移量找到相对于基地址的具体字节位置。
- **段的访问权限**：只有在**当前权限级别 (CPL)** 允许的情况下，才能访问该段中的代码、数据或堆栈。
### GDT和LDT寄存器
- **GDT寄存器 (GDTR)**：存储GDT的**线性基地址**。
- **LDT寄存器 (LDTR)**：存储LDT的**线性基地址**。
*在IA-32e模式下，GDTR和LDTR也相应的被拓展为了64位，进而支持更大的地址空间。*
GDT和LDT是内存管理的核心，它管理**段内存的访问**，并且提供了**访问控制**和**隔离机制**
*值得注意的是，LDT也可以作为段，通过段选择子和段描述符访问，但GDT不行。详见下一部分系统段。*
## 2.1.2 系统段、段描述符、门
### 系统段与系统描述符
除了构成程序或过程执行环境的**代码段、数据段**和**堆栈段**，IA-32架构还定义了两个**系统段**：
- **任务状态段 (TSS, Task-State Segment)**：保存任务的运行状态信息，用于多任务切换。
- **局部描述符表 (LDT, Local Descriptor Table)**：为特定任务提供私有的段描述符表。
*这两个段都可以通过系统段描述符，进行标识和管理。他们的存在是为了管理其他段或任务。*
### 门
*门属于一种描述符，但是比较特殊，打通了不同特权级之间，提供了一个受保护的入口。这样就可以允许代码段访问相同或更高特权级的代码段*？段到底是什么
常见的门类型：
- **调用门 (Call Gate)**：用于访问在更高特权级的代码段中的过程。
- **中断门 (Interrupt Gate)**：处理外部中断事件。
- **陷阱门 (Trap Gate)**：处理陷阱和异常。
- **任务门 (Task Gate)**：用于切换到另一个任务的TSS（但在IA-32e模式中不再支持）。
## 2.1.3 任务状态段 (TSS) 和任务门 (Task Gates)
TSS主要管理任务执行环境的状态，包括以下内容：
- **通用寄存器**和**段寄存器**的状态
- **EFLAGS和EIP寄存器**（用于标志位和指令指针）
- **每个特权级别的堆栈段选择子和堆栈指针**
- **LDT段选择子**（任务关联的局部描述符表）
- **分页结构的基地址**
并且这个TSS的段选择子保存在**任务寄存器**中
而任务门提供**TSS访问的入口**，允许其切换任务。那么是如何切换任务的呢
- 将当前任务的状态保存到其TSS中。
- 将任务寄存器更新为新任务的TSS段选择子。
- 从GDT中访问新任务的TSS段描述符。
- 加载新任务的状态，包括寄存器、LDT选择子、分页控制寄存器CR3、EFLAGS和EIP。
- 执行新任务。
*在IA-32e模式中，硬件任务切换不再支持了，这时候的TSS变为64位*，并管理以下内容：
- 每个特权级别的堆栈指针
- 中断堆栈表的指针
- IO许可位图的偏移量
## 2.1.4 中断与异常处理
采用**中断描述符表IDT**和**IDTR（寄存器）**，专门存储访问**中断处理程序**和**异常处理程序**的门描述符。处理过程：
- 处理器从硬件或软件（如INT指令）接收**中断向量**。
- **中断向量**用作IDT中的索引，定位到中断或异常处理的门描述符。
- 如果门是**中断门或陷阱门**，处理器调用相应的处理程序。
- 如果门是**任务门**，则触发任务切换。
*同样在IA-32e模式中不支持*
## 2.1.5 内存管理
*采用物理寻址和分页机制。在IA-32e中，使用四级分页结构*
1. **PML4表**：每个条目指向页目录指针表。
2. **页目录指针表**：每个条目指向页目录表。
3. **页目录表**：每个条目指向页表。
4. **页表**：每个条目指向物理页框。
CR3寄存器用于存储分页结构的基地址
## 2.1.6 系统寄存器
**系统寄存器**用于初始化处理器并控制系统操作：
- **EFLAGS寄存器**：控制任务和模式切换、中断处理和指令追踪。
- **控制寄存器 (CR0–CR4)**：控制系统级操作，如分页和特性启用。
- **调试寄存器 (DR0–DR7)**：用于设置断点，辅助调试。
- **GDTR、LDTR和IDTR寄存器**：存储描述符表的线性基地址和大小。
- **任务寄存器 (TR)**：存储当前任务的TSS地址。
IA-32e模式下的系统寄存器：
- **GDTR、IDTR、LDTR和TR**扩展为64位。
- **EFLAGS寄存器**变为64位的**RFLAGS**。
- 新增**CR8寄存器**，用于控制任务优先级寄存器 (TPR) 的优先级。
- IA-32e模式还引入了**模型特定寄存器 (MSRs)**，如：
    - **IA32_KernelGSbase**：用于SWAPGS指令。
    - **IA32_LSTAR**：用于SYSCALL指令。
    - **IA32_SYSCALL_FLAG_MASK** 和 **IA32_STAR_CS**：控制SYSCALL和SYSRET指令。
## 总结
通过一些系统资源和机制，实现了在IA-32（e）中对内存寻址，任务切换，代码执行和特权级别。对于操作系统开发，内存管理是最重要的事情之一。
# 2.2 操作模式
IA-32架构支持三种主要的**操作模式**和一种**准操作模式**：
1. **保护模式 (Protected Mode)**
    - 保护模式是处理器的本地操作模式，提供了丰富的体系结构特性，包括灵活性、高性能，并与旧版软件向下兼容。
    - 这是操作系统通常使用的模式，支持多任务、内存保护和虚拟内存。
2. **实地址模式 (Real-Address Mode)**
    - 模拟Intel 8086处理器的编程环境，并增加了一些扩展功能，如从实模式切换到保护模式或系统管理模式。
    - 在系统启动或重置时，处理器会进入实地址模式。
3. **系统管理模式 (SMM, System Management Mode)**
    - SMM是一种特殊模式，用于电源管理和OEM差异化特性的实现。
    - 进入SMM时，处理器会响应系统管理中断 (SMI)，切换到一个独立的地址空间，并保存当前程序的上下文。
    - RSM指令用于退出SMM，并恢复到中断发生前的状态。
4. **虚拟8086模式 (Virtual-8086 Mode)**
    - 虚拟8086模式允许在保护模式下运行8086软件，提供了一种受保护的多任务环境。
IA-32e为了实现对64架构支持，实现了64位模式和兼容模式。
### 模式切换
在模式之间切换需要以下流程：
- **保护模式与虚拟8086模式之间的切换**：
    - **EFLAGS寄存器**中的VM标志控制是否进入虚拟8086模式。
    - 这种模式切换通常发生在任务切换或中断/异常处理的过程中。
- **进入IA-32e模式的过程**：
    - IA32_EFER寄存器中的LME位 (bit 8) 用于启用IA-32e模式。
    - IA32_EFER.LMA位 (bit 10) 指示处理器当前是否处于IA-32e模式。
    - IA-32e模式可以通过分页启用并设置**LME位**来从保护模式切换而来。
- **进入系统管理模式 (SMM)**：
    - 无论处理器当前在哪个模式（实地址模式、保护模式、虚拟8086模式或IA-32e模式），只要收到**SMI中断**，处理器就会切换到SMM。
    - RSM指令将处理器恢复到中断发生前的模式。
## IA32_EFER寄存器
IA32_EFER寄存器提供了几个用于控制IA-32e模式的字段：
- Bit 0：启用**SYSCALL/SYSRET指令**（用于系统调用）。
- Bit 8：启用**IA-32e模式**。
- Bit 10：指示IA-32e模式是否**激活**（只读）。
- Bit 11：启用执行禁止 (Execute Disable, **XD**) 位，防止从特定页面执行指令。
# 2.3 EFLAGS寄存器的系统标志与字段
 EFLAGS中的系统标志与字段
1. **TF (Trap Flag, bit 8)**
    - 作用：启用单步模式，每执行一条指令后生成一个调试异常，方便逐步检查程序状态。
    - 使用场景：调试程序时，TF标志允许逐条指令执行并检查结果。
    - 注意：如果用户程序通过POPF、POPFD或IRET指令设置该标志，则紧随其后的指令会触发调试异常。
2. **IF (Interrupt Enable Flag, bit 9)**
    
    - **作用**：控制处理器对**可屏蔽硬件中断**的响应。
    - **设置**：IF=1时响应中断，IF=0时屏蔽中断。
    - **限制**：该标志不能影响异常或不可屏蔽中断（NMI）。只有在**合适的权限级别**下（受**CPL、IOPL和CR4.VME**的控制），CLI、STI等指令才能修改IF标志。
3. **IOPL (I/O Privilege Level, bits 12-13)**
    
    - **作用**：指示当前程序的I/O权限级别。
    - **机制**：**当前程序的CPL**必须小于或等于**IOPL**，才能访问I/O地址空间。
    - **修改条件**：只有在CPL=0时，POPF和IRET指令才能修改该字段。
    - **作用于虚拟8086模式**：配合CR4寄存器中的VME标志使用。
4. **NT (Nested Task, bit 14)**
    
    - **作用**：控制任务的嵌套调用链。当通过CALL指令或中断调用任务时，处理器会设置该标志。
    - **返回任务**时（通过IRET指令），处理器会检查并修改该标志。
    - **注意**：如果应用程序不慎修改此标志，可能导致意外异常。
5. **RF (Resume Flag, bit 16)**
    
    - **作用**：用于处理**指令断点**。当设置该标志时，处理器暂时忽略由断点引发的调试异常。
    - **典型用途**：调试软件在IRETD返回前设置该标志，以避免再次触发相同的断点异常。处理器在返回后会自动清除RF标志。
6. **VM (Virtual-8086 Mode, bit 17)**
    
    - **作用**：启用**虚拟8086模式**。
    - **说明**：该模式允许在保护模式下运行8086软件。
7. **AC (Alignment Check, bit 18)**
    
    - **作用**：用于检查**内存对齐**。若数据不对齐（如双字未按4字节对齐），处理器会生成对齐检查异常。
    - **限制**：仅在**用户模式（CPL=3）**下会生成对齐异常。
8. **VIF (Virtual Interrupt Flag, bit 19)**
    
    - **作用**：保存IF标志的虚拟映像，用于虚拟化中断处理。
9. **VIP (Virtual Interrupt Pending, bit 20)**
    
    - **作用**：指示中断是否待处理。该标志由软件设置或清除。
10. **ID (Identification Flag, bit 21)**
    

- **作用**：指示系统是否支持**CPUID指令**。