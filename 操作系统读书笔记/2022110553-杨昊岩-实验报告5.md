### 1. 基于模板 `process.c` 编写多进程的样本程序，实现如下功能
- 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 `30` 秒；
- 父进程向标准输出打印所有子进程的 `id` ，并在所有子进程都退出后才退出；
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/times.h>
#define HZ	100

void cpuio_bound(int last, int cpu_time, int io_time);

int main(int argc, char * argv[])
{
	pid_t fd1, fd2;
	int fd;
	
	printf("parent pid = [%d]\n", getpid());

	fd1 = fork();
	if(fd1 == 0)
	{
		printf("[%d] is running\n", getpid());
		cpuio_bound(10, 1, 0);
		exit(0);
	}

	fd2 = fork();
	if(fd2 == 0)
	{
		printf("[%d] is running\n", getpid());
		cpuio_bound(10, 1, 0);
		exit(0);
	}

	fd = wait(NULL);
	printf("[%d] exit\n",fd);

	fd = wait(NULL);
	printf("[%d] exit\n",fd);

	return 0;
}

void cpuio_bound(int last, int cpu_time, int io_time)
{
	struct tms start_time, current_time;
	clock_t utime, stime;
	int sleep_time;

	while (last > 0)
	{
		/* CPU Burst */
		times(&start_time);
		/* 只有t.tms_utime才是真正的CPU时间。*/
		do
		{
			times(&current_time);
			utime = current_time.tms_utime - start_time.tms_utime;
			stime = current_time.tms_stime - start_time.tms_stime;
		} while ( ( (utime + stime) / HZ )  < cpu_time );
		last -= cpu_time;

		if (last <= 0 )
			break;
		/* IO Burst */
		/* 用sleep(1)模拟1秒钟的I/O操作 */
		sleep_time=0;
		while (sleep_time < io_time)
		{
			sleep(1);
			sleep_time++;
		}
		last -= sleep_time;
	}
}
```
