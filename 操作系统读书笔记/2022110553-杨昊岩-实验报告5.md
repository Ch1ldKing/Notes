### 1. 基于模板 `process.c` 编写多进程的样本程序，实现如下功能
- 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 `30` 秒；
- 父进程向标准输出打印所有子进程的 `id` ，并在所有子进程都退出后才退出；
**做法**
修改`process.c`模板，实现两个子进程并行，大致思路如下：
1. 创建两个进程标识符`fd1,fd2`
2. 使用`fork()`来建立子进程，分配给`fd1,fd2`
3. 如果创建成功，那么在子进程中，满足`fd==0`，可用if语句判断进入子进程
4. 在子进程中输出进程运行信息，并利用`cpuio_bound(10, 1, 0)`使子进程占用CPU 10s，满足要求中的30秒内
5. 通过`wait()`调用等待子进程结束，结束后输出进程结束
修改后的main代码：（中文显示不出来，此处为展示，运行还是改英文了）
```c
int main(int argc, char * argv[])
{
	pid_t fd1, fd2;
	int fd;
	
	printf("父进程id = [%d]\n", getpid());

	fd1 = fork();
	if(fd1 == 0)
	{
		printf("子进程 [%d] 运行中\n", getpid());
		cpuio_bound(10, 1, 0);
		exit(0);
	}

	fd2 = fork();
	if(fd2 == 0)
	{
		printf("子进程 [%d] 运行中\n", getpid());
		cpuio_bound(10, 1, 0);
		exit(0);
	}

	fd = wait(NULL);
	printf("[%d] 退出\n",fd);

	fd = wait(NULL);
	printf("[%d] 退出\n",fd);

	return 0;
}
```
编译运行，可以看到两个子进程
![image.png](https://s2.loli.net/2025/01/04/ufOE5K8tc6qrhUb.png)
### 2. 在 `Linux 0.11` 上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件 `/var/process.log` ，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 `log` 文件中
**首先**，修改`init/main.c`，在操作系统启动到关机过程中，每个进程状态切换的时候，写入记录到`var/process.log`中。这样就需要内核在刚刚启动后就打开日志文件进行记录
修改`main.c`大致思路如下：
1. 内核启动的入口是`main()`，在进程`0`中运行。进程`0`用于初始化系统，
2. 写入文件使用系统调用，所以必须在用户态下进行，因此在`move_to_user_mode()`后进行打开文件