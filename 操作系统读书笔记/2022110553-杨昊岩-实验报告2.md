### 1. 当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况
1. 打断点`0x9d`，定位到进入task0的语句
2. 单步执行进入int 0x80调用的系统中断
3. 执行到iret命令，记录栈情况![image.png](https://s2.loli.net/2024/11/25/R9OMlden2NKi4VC.png)
4. 执行，记录栈情况![image.png](https://s2.loli.net/2024/11/25/U6HjFpCIlMNvnAu.png)
总结变化情况如下表

| 状态<div style="width:100px"></div> | 栈指针 (ESP) | 栈内容 (从高地址到低地址) | 描述                   |
| --------------------------------- | :-------: | :------------: | -------------------- |
| `iret`前                           |   0xe4c   |     0x10eb     | EIP (返回到指令地址)        |
|                                   |   0xe50   |      0x0f      | CS (代码段选择子)          |
|                                   |   0xe54   |     0x246      | EFLAGS (标志寄存器)       |
|                                   |   0xe58   |     0xbd8      | ESP(用户栈顶指针)          |
| `iret`后                           |   0xbd8   |     0xbd8      | 栈恢复到中断前状态<br>指向用户代码栈 |

我们回到执行`int 0x80`前：
![image.png](https://s2.loli.net/2024/11/25/FsQ1D2AUt9WT4k8.png)
可以看到在进入系统中断前的状态，如下表所示，与系统中断执行iret后的场景一致

| 寄存器<div style="width:380px"></div> | 值<div style="width:280px"></div> |
| :--------------------------------: | :------------------------------: |
|              CS代码段选择子              |               0x0f               |
|              ESP栈顶指针               |              0xbd8               |
|            EFLAGS标志寄存器             |              0x246               |
由此可知iret使寄存器**恢复**到了执行系统中断前的执行上下文，并且执行iret后，EIP指向task0中下一条指令的线性地址
### 2. 当进入和退出 `system_interrupt` 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？
#### 特权级变化
- 当进入系统中断时，特权级CPL从3到0；退出系统中断时，特权级CPL从0到3
IDT中断门初始化代码如下
```asm
movw $system_interrupt, %ax    # 偏移地址的低 16 位
movw $0xef00, %dx              # 中断门属性
lea idt(,%ecx,8), %esi         # 定位到 IDT 表中对应的描述符位置
movl %eax, (%esi)              # 写入偏移地址低 16 位和段选择子（0x08）
movl %edx, 4(%esi)             # 写入属性字段和偏移地址高 16 位
```
- `0xef00`定义了中断门的属性，最后几位转化为二进制是`1110111100000000`
其中，从左向右数的2,3位为CPL值，为11，即3，表示用户模式可访问该中断门。
- 触发中断后CPU将特权级CPL切换到0，即切换到内核模式。这时会加载内核代码段，CS变为`0x08`，跳转到内核代码执行中断处理
#### 栈切换
##### 进入系统中断前后
进入系统中断前
![image.png](https://s2.loli.net/2024/12/01/FV3MPRTfwDHvtBA.png)
进入系统中断后
![image.png](https://s2.loli.net/2024/12/01/1pZDBMrYt2Haolm.png)
可见，保存用户模式的栈状态，然后切换到内核栈，根据TSS0中的定义，将SS切换到`0x10`，ESP切换到内核栈顶指针`krn_stk0`
出系统中断前
##### 退出系统中断前后
退出系统中断前
![image.png](https://s2.loli.net/2024/12/01/ljX9JtfaHgK3hkI.png)
退出系统中断后
![image.png](https://s2.loli.net/2024/12/01/lfaujeCcg28E7Xq.png)
可见，从栈中弹出了用户模式的所有上下文，从栈中先后弹出用户模式下 **ESP 和 SS 的值**，切换回用户栈`0x17`与用户栈顶指针0xbd8
##### 总结栈变化
**进入系统中断前后**

| 寄存器 | 进入前   | 进入后   | 解释如何切换                                                                                            |
| --- | ----- | ----- | ------------------------------------------------------------------------------------------------- |
| SS  | 0x17  | 0x10  | 从用户栈切换到内核栈，在TSS0中定义，且用户栈被压栈，由**CPU**根据**TR寄存器**中的TSS0的**选择子**，从**GDT**中加载TSS0**任务状态段**中ss0，切换到内核栈 |
| ESP | 0xbd8 | 0xe4c | 切换到内核栈顶指针，在TSS0中定义，切换方式同上，加载TSS0任务状态段，加载esp0的值                                                    |
**退出系统中断前后**

| 寄存器 | 退出前   | 退出后   | 解释如何切换                                                      |
| --- | ----- | ----- | ----------------------------------------------------------- |
| SS  | 0x10  | 0x17  | 从内核栈切换回用户栈，从内核栈中弹出用户模式下的上下文，其中也包括**用户栈SS**的值，重新赋值给SS**寄存器** |
| ESP | 0xe4c | 0xbd8 | 切换回用户栈顶指针，切换方式同上，从栈中弹出用户模式的**栈顶指针ESP**的值，赋值给ESP寄存器          |
### 3. 当时钟中断发生，进入到 `timer_interrupt` 程序，请详细记录从任务 `0` 切换到任务 `1` 的过程
1. 首先打断点`b 0x12b`，此时已经执行过任务0，输出了10个A，进入到`timer_interrupt`中![image.png](https://s2.loli.net/2024/12/03/4zRoUT6j9EbNCgL.png)
2. 执行到 0x12c ，这两行代码切换到内核模式的代码段![image.png](https://s2.loli.net/2024/12/03/oG1YrvKOhuldbxI.png)
3. 执行到 0x137，进行任务调度处理，判断当前任务是否为任务1，然后根据不同情况进行远跳指令![image.png](https://s2.loli.net/2024/12/03/EPZyJQvK8DU9Ie1.png)
4. 现在将要首次进入到任务1中，先查看一下GDT表，并用`info tss`查看一下当前的TSS![image.png](https://s2.loli.net/2024/12/03/WkpMaQAO3zCPF4w.png)可以看到当前的TSS和GDT表中的 Busy TSS可以对应上选择子的index
   而任务1的TSS选择子`0x30`未执行，这条指令的选择子也正是任务1的
5. 执行后，刷新一下，查看GDT然后`info tss`查看TSS![image.png](https://s2.loli.net/2024/12/03/zkrB9iqLNcw4p7J.png)可以看到发生了切换，现在位于task1的入口处，目前的TSS变为`0x30`，并且各寄存器的值也和TSS中的字段一致。
### 4.又过了 `10ms` ，从任务`1`切换回到任务 `0` ，整个流程是怎样的？ `TSS` 是如何变化的？各个寄存器的值是如何变化的？
1. 接着上一次的程序运行，同样是`b 0x12b`的断点，这次运行到第二次，屏幕输出10个A和10个B，并且GDT和TSS中显示当前执行的也是TSS1![image.png](https://s2.loli.net/2024/12/03/fQybpH1e2o9iLzR.png)
2. 单步执行到远跳指令，这一次直接跳过了`jmp far 0030`，因为判断当前任务为task1![image.png](https://s2.loli.net/2024/12/03/xu2qROcXh8gKPpw.png)
3. 单步执行，CS:EIP 变为了第一次任务切换后的下一条指令`0x08:0x150`。这个原因是上一次任务切换的时候，执行现场被保存到了TSS0中。![image.png](https://s2.loli.net/2024/12/03/DimW36SMtKVYZpo.png)
### 5. 请详细总结任务切换的过程
任务切换是实现多任务执行的核心，大致需要保存上下文，加载上下文，一般通过时间中断触发任务切换，总结一下详细流程：
1. 周期性触发**时间中断**，本程序10ms，触发时跳转到时间中断程序`timer_interrupt`，然后切换到内核模式
```asm
push %ds
pushl %eax
movl $0x10, %eax        
mov %ax, %ds
```
2. **判断**需要切换的任务，比如本程序通过`current`变量的值来判断
```asm
movl $1, %eax          
cmpl %eax, current
je 1f
```
3. 通过**远跳指令**，通过刚刚判断切换的任务对应的**选择子**，来跳转到相应的任务
```asm
movl %eax, current      
ljmp $TSS1_SEL, $0      
1: movl $0, current 
ljmp $TSS0_SEL, $0 
```
4. 从TSS中加载执行任务的上下文和寄存器现场，最终切换完成后通过`iret`退出并恢复任务状态，更改权限CPL，并弹出各寄存器的值
```asm
popl %eax
pop %ds
iret
```
