### 1. 当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况
1. 打断点`0x9d`，定位到进入task0的语句
2. 单步执行进入int 0x80调用的系统中断
3. 执行到iret命令，记录栈情况![image.png](https://s2.loli.net/2024/11/25/R9OMlden2NKi4VC.png)
4. 执行，记录栈情况![image.png](https://s2.loli.net/2024/11/25/U6HjFpCIlMNvnAu.png)
我们回到执行`int 0x80`前：
![image.png](https://s2.loli.net/2024/11/25/FsQ1D2AUt9WT4k8.png)
可以看到在进入系统中断前的状态，如下表所示，与系统中断执行iret后

| 寄存器<div style="width:380px"></div> | 值<div style="width:280px"></div> |
| :--------------------------------: | :------------------------------: |
|              CS代码段选择子              |               0x0f               |
|              ESP栈顶指针               |              0xbd8               |
|            EFLAGS标志寄存器             |              0x246               |


| 状态          | 栈指针 (ESP)  | 栈内容 (从高地址到低地址) | 描述                |
| ----------- | ---------- | -------------- | ----------------- |
| **`iret`前** | 0x000004EC | 0x000017C      | `EIP` (返回地址)      |
|             | 0x000004E8 | 0x00000017     | `CS` (代码段选择子)     |
|             | 0x000004E4 | 0x00000246     | `EFLAGS` (标志寄存器)  |
| **`iret`后** | 0x00000BD8 | ...            | 栈清空到中断前状态，指向用户代码栈 |
