### 1. 当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况
1. 打断点`0x9d`，定位到进入task0的语句
2. 单步执行进入int 0x80调用的系统中断
3. 执行到iret命令，记录栈情况![image.png](https://s2.loli.net/2024/11/25/R9OMlden2NKi4VC.png)
4. 执行，记录栈情况![image.png](https://s2.loli.net/2024/11/25/U6HjFpCIlMNvnAu.png)
总结变化情况如下表

| 状态<div style="width:100px"></div> | 栈指针 (ESP) | 栈内容 (从高地址到低地址) | 描述                |
| --------------------------------- | --------- | -------------- | ----------------- |
| `iret`前                           | 0xe4c     | 0x10eb         | `EIP` (返回dao地址)   |
|                                   | 0x4e8     | 0x017          | `CS` (代码段选择子)     |
|                                   | 0x4e4     | 0x246          | `EFLAGS` (标志寄存器)  |
|                                   |           |                |                   |
| `iret`后                           | 0xbd8     | 0xbd8          | 栈清空到中断前状态，指向用户代码栈 |

我们回到执行`int 0x80`前：
![image.png](https://s2.loli.net/2024/11/25/FsQ1D2AUt9WT4k8.png)
可以看到在进入系统中断前的状态，如下表所示，与系统中断执行iret后的场景一致，并且执行iret后，EIP指向task0中下一条指令的线性地址

| 寄存器<div style="width:380px"></div> | 值<div style="width:280px"></div> |
| :--------------------------------: | :------------------------------: |
|              CS代码段选择子              |               0x0f               |
|              ESP栈顶指针               |              0xbd8               |
|            EFLAGS标志寄存器             |              0x246               |
由此可知iret使寄存器**恢复**到了执行系统中断前的执行上下文
