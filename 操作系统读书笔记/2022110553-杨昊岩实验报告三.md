# 实验内容
### 1. 改写 `bootsect.s`
首先，在`bootsect.s`中定位到以下代码
```asm
msg1:
	.byte 13,10
	.ascii "ChildKing OS is running ..."
	.byte 13,10,13,10
```
然后需要找到显示的部分代码，修改需要显示的长度
```asm
! Print some inane message

	mov	ah,#0x03		! read cursor pos
	xor	bh,bh
	int	0x10
	
	mov	cx,#32
	mov	bx,#0x0007		! page 0, attribute 7 (normal)
	mov	bp,#msg1
	mov	ax,#0x1301		! write string, move cursor
	int	0x10
```
然后编译运行，可以看到显示出来
![image.png](https://s2.loli.net/2024/12/11/d8wnGMSHy4jhqQA.png)
### 2. 改写 `setup.s`，使 `bootsect.s` 能完成 `setup.s` 的载入，并跳转到 `setup.s` 开始地址执行。而 `setup.s` 向屏幕输出一行
1. 执行`make clean`，清除刚刚的编译结果
2. 参照`bootsect.s`中显示信息的代码，将`setup.s`进行修改
```asm
entry _start
_start:
	mov	ax,cs
	mov	ds,ax
	mov	es,ax

	mov	ah,#0x03		! read cursor pos
	xor	bh,bh
	int	0x10
	
	mov	cx,#23
	mov	bx,#0x000c		! page 0, attribute c 
	mov	bp,#msg1
	mov	ax,#0x1301		! write string, move cursor
	int	0x10
msg1:
	.byte 13,10
	.ascii "Setup ChildKing OS"
	.byte 13,10,13,10
```
3. 重新`make all`，然后运行`./run`
4. 单步执行，显示出`Setup.s`中的内容![image.png](https://s2.loli.net/2024/12/11/3ivMj5IWUse2gbR.png)
### 3. `setup.s` 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等）， 将其存放在内存的特定地址，并输出到屏幕上
按照指导手册，需要增加以下部分：
1. 获取光标位置
```asm
    mov ax,#INITSEG
    mov ds,ax
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov [0],dx
```
2. 获取内存大小
```asm
    mov ah,#0x88
    int 0x15
    mov [2],ax
```
3. 获取硬盘参数
```asm
	mov ax,#0x0000
	mov ds,ax 
	lds si,[4*0x41]
	mov ax,#INITSEG
	mov es,ax 
	mov di,#0x0004 
	mov cx,#0x10 
	rep
	movsb
```
4. 初始化段寄存器用于存储硬件信息和屏幕输出
```asm
	 mov ax,cs ; 0x07e0
	 mov es,ax
	 mov ax,#INITSEG
	 mov ds,ax
```
5. 输出指针坐标
```asm
	 mov cx,#18
	 mov bx,#0x0007
	 mov bp,#cursor_msg
	 mov ax,#0x1301
	 int 0x10
	 mov dx,[0]
	 call print_hex
```
6. 输出内存大小
```asm
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#14
	mov bx,#0x0007
	mov bp,#memory_msg
	mov ax,#0x1301
	int 0x10
	mov dx,[2] 
	call print_hex
```
7. 输出一个内存的单位KB
```asm
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#2
	mov bx,#0x0007
	mov bp,#kb_msg
	mov ax,#0x1301
	int 0x10
```
8. 输出硬盘柱面信息
```asm
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#7
	mov bx,#0x0007
	mov bp,#cylin_msg
	mov ax,#0x1301
	int 0x10
	mov dx,[4]
	call print_hex
```
9. 输出硬盘磁头信息
```asm
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#8
	mov bx,#0x0007
	mov bp,#heads_msg
	mov ax,#0x1301
	int 0x10
	mov dx,[6]
	call print_hex
```
10. 输出扇区信息
```asm
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#10
	mov bx,#0x0007
	mov bp,#msg_sectors
	mov ax,#0x1301
	int 0x10
	mov dx,[12]
	call print_hex
```
11. 由于执行完这些程序会退出，所以在结尾加一个死循环
```asm
inf_loop:
	 jmp inf_loop
```
12. 加上手册中提到的一些显示用的函数
```asm
print_hex:
    mov cx,#4 
print_digit:
    rol dx,#4 
    mov ax,#0xe0f 
    and al,dl 
    add al,#0x30
    cmp al,#0x3a 
    jl outp
    add al,#0x07
outp:
    int 0x10
    loop print_digit
    ret
```
13. 定义需要显示的信息
```asm
msg1:
	.byte 13,10
	.ascii "Setup ChildKing OS"
	.byte 13,10,13,10
cursor_msg:
	.byte 13,10
	.ascii "Cursor position:"
memory_msg:
	.byte 13,10
	.ascii "Memory Size:"
kb_msg:
	.ascii "KB"
cylin_msg:
	.byte 13,10
	.ascii "Cyls:"
heads_msg:
	.byte 13,10
	.ascii "Heads:"
sectors_msg:
	.byte 13,10
	.ascii "Sectors:"
```
重新编译运行，即可看到结果
![image.png](https://s2.loli.net/2024/12/11/etuYWrJc9gxDoZT.png)
查看`bochsrc.bxrc`，结果一致，但是输出显示的是十六进制，转化后的值是一样的![image.png](https://s2.loli.net/2024/12/11/l3GFmVWr7BA2jIQ.png)
### 4. 
## Problem
### 1. 
一开始在和Windows的共享文件夹里git了实验环境，执行`./setup.sh`出错
```sh
/bin/sh^M: bad interpreter: No such file or directory
```
猜测可能是换行符错误，win下git会自动将换行符转化为CRLF格式
于是在ubuntu中安装git，然后重新拉取，运行成功
### 2.
bochs配置文件中的图形库有问题，改成`display_library x`或者完全删掉也可以，也可以在这里配置图形化界面
