# 全局变量
1. `SOCKET ProxyServer = INVALID_SOCKET;`定义代理服务器的套接字，初始化为空套接字
2. `sockaddr_in ProxyServerAddr;`定义代理服务器的套接字地址和端口信息。`sockaddr_in`专门用于IPv4，存储sin_family，sin_port，sin_addr（存放32位数）
3. `const int ProxyPort = 10240;`定义代理服务器的监听端口
4. 代理服务器中，需要存储的客户端与目标服务器的套接字
```cpp
struct ProxyParam
	{
	    SOCKET clientSocket; // 客户端套接字
	    SOCKET serverSocket; // 目标服务器套接字
	};
```
5. Http首部（请求头），包括请求方法，请求url，目标主机名，cookie，还有个构造函数
```cpp
struct HttpHeader
{
    char method[4]; // 定义 HTTP 请求方法，例如 POST 或 GET
    char url[1024]; // 定义请求的 URL
    char host[1024]; // 定义目标主机名
    char cookie[1024 * 10]; // 定义请求的 Cookie 信息
    HttpHeader()
    {
        ZeroMemory(this, sizeof(HttpHeader)); // 将 HttpHeader 结构体初始化为 0
    }
};
```
6. 缓存的报文格式，同时定义数组存储1024条缓存，并且记录当前缓存的index和缓存数量
```cpp
struct HttpCache
{
    char url[1024]; // 定义缓存的 URL
    char host[1024]; // 定义缓存的主机名
    char last_modified[200]; // 定义缓存的最后修改时间
    char status[4]; // 定义缓存的状态码
    char buffer[MAXSIZE]; // 定义缓存的数据缓冲区
    HttpCache()
    {
        ZeroMemory(this, sizeof(HttpCache)); // 初始化 HttpCache 结构体
    }
};
HttpCache Cache[1024]; // 定义缓存数组，最多存储 1024 条缓存记录
int cached_number = 0; // 当前已缓存的 URL 数量
int last_cache = 0;    // 上一次缓存的索引位置
```

# 1. 初始化Winsock套接字库

```cpp
BOOL InitWsa()
{
    WORD wVersionRequested; // 定义请求的 Winsock 版本
    WSADATA wsaData; // Winsock 数据结构体
    int err; // 错误码
    wVersionRequested = MAKEWORD(2, 2); // 请求 Winsock 2.2 版本
    err = WSAStartup(wVersionRequested, &wsaData); // 初始化 Winsock
    if (err != 0)
    {
        printf("加载 winsock 失败， 错误代码为: %d\n", WSAGetLastError()); // 输出错误信息
        return FALSE; // 返回失败
    }
    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2)
    {
        printf("不能找到正确的 winsock 版本\n"); // 输出版本不正确信息
        WSACleanup(); // 释放 Winsock 资源
        return FALSE; // 返回失败
    }
    return TRUE; // 返回成功
}
```

这部分初始化2.2版本的Winsock
# 2.初始化套接字

```cpp
BOOL InitSocket()
{
    ProxyServer = socket(AF_INET, SOCK_STREAM, 0); // 创建代理服务器的 IPv4 TCP 套接字
    if (INVALID_SOCKET == ProxyServer)
    {
        printf("创建套接字失败，错误代码为：%d\n", WSAGetLastError()); // 输出错误信息
        return FALSE; // 返回失败
    }
    ProxyServerAddr.sin_family = AF_INET; // 设置为 IPv4 地址族
    ProxyServerAddr.sin_port = htons(ProxyPort); // 设置代理服务器的端口号，使用 htons 转换为网络字节序
    ProxyServerAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); // 设置代理服务器只允许本机访问
    // 绑定端点地址和套接字
    if (bind(ProxyServer, (SOCKADDR*)&ProxyServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)//sizeof是被bind()提供地址结构体大小，也可以是ProxyServerAddr的大小
    {
        printf("绑定套接字失败\n"); // 输出绑定失败信息
        return FALSE; // 返回失败
    }
    //进入监听状态
    if (listen(ProxyServer, SOMAXCONN) == SOCKET_ERROR)//SOMAXCONN是连接请求等待队列的最大长度
        
    {
        printf("监听端口%d 失败", ProxyPort); // 输出监听失败信息
        return FALSE; // 返回失败
    }
    return TRUE; // 返回成功
}
```

1. `socket()`新建套接字，传入`AF_INET`代表IPv4，`SOCK_STREAM`代表TCP，赋值给代理服务器套接字
2. `ProxyServerAddr`存放信息，包括地址族，代理服务器的端口号（用`htons`转换字符串），代理服务器接收的ip地址（用`inet_addr`转换字符串）
3. `bind()`把刚创建的代理服务器套接字绑定在存放的地址和端口上
4. `listen()`把刚才的代理服务器套接字转化为监听状态，并设置最大连接数

# 3. 接收客户端连接

```cpp
    SOCKET acceptSocket = INVALID_SOCKET; // 用于真正通信的套接字，初始化为无效套接字
    SOCKADDR_IN acceptAddr;               // 客户端端点信息
    ProxyParam* lpProxyParam;             // 代理服务器参数
    HANDLE hThread;                       // 线程句柄
    DWORD dwThreadID;                     // 线程ID

    // 代理服务器不断监听
    while (true)
    {
        acceptSocket = accept(ProxyServer, (SOCKADDR*)&acceptAddr, NULL); 
        //ProxyServer监听连接，当客户端连接时，accept()将客户端的信息等填入acceptAddr，并创建这个用于处理连接的套接字

        lpProxyParam = new ProxyParam;
        if (lpProxyParam == NULL) continue;
        lpProxyParam->clientSocket = acceptSocket;
        hThread = (HANDLE)_beginthreadex(NULL, 0,
            &ProxyThread, (LPVOID)lpProxyParam, 0, 0);
        CloseHandle(hThread);
        Sleep(200);
    }
```

1. 创建一个用于连接客户端的套接字，并创建用于存储客户端信息的结构体
2. `accept()`在不断监听的情况下，接收客户端的连接，当有连接时，存储客户端信息，并创建一个处理该连接的套接字
3. 代理服务器需要绑定这个客户端套接字，存储在`ProxyParam`中，作为clientSocket
4. 创建一个线程，来执行`ProxyThread()`，并传入参数`ProxyParam`
5. 关闭线程，关闭线程

# 4. 处理客户端连接
