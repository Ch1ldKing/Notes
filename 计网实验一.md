# 全局变量
1. `SOCKET ProxyServer = INVALID_SOCKET;`定义代理服务器的套接字，初始化为空套接字
2. `sockaddr_in ProxyServerAddr;`定义代理服务器的套接字地址和端口信息。`sockaddr_in`专门用于IPv4，存储sin_family，sin_port，sin_addr
3. `const int ProxyPort = 10240;`定义代理服务器的监听端口
4. 代理服务器中，需要存储的客户端与目标服务器的套接字
```cpp
struct ProxyParam
	{
	    SOCKET clientSocket; // 客户端套接字
	    SOCKET serverSocket; // 目标服务器套接字
	};
```
5. Http首部（请求头），包括请求方法，请求url，目标主机名，cookie，还有个构造函数
```cpp
struct HttpHeader
{
    char method[4]; // 定义 HTTP 请求方法，例如 POST 或 GET
    char url[1024]; // 定义请求的 URL
    char host[1024]; // 定义目标主机名
    char cookie[1024 * 10]; // 定义请求的 Cookie 信息
    HttpHeader()
    {
        ZeroMemory(this, sizeof(HttpHeader)); // 将 HttpHeader 结构体初始化为 0
    }
};
```
6. 缓存的报文格式，同时定义数组存储1024条缓存，并且记录当前缓存的index和缓存数量
```cpp
struct HttpCache
{
    char url[1024]; // 定义缓存的 URL
    char host[1024]; // 定义缓存的主机名
    char last_modified[200]; // 定义缓存的最后修改时间
    char status[4]; // 定义缓存的状态码
    char buffer[MAXSIZE]; // 定义缓存的数据缓冲区
    HttpCache()
    {
        ZeroMemory(this, sizeof(HttpCache)); // 初始化 HttpCache 结构体
    }
};
HttpCache Cache[1024]; // 定义缓存数组，最多存储 1024 条缓存记录
int cached_number = 0; // 当前已缓存的 URL 数量
int last_cache = 0;    // 上一次缓存的索引位置
```

# 1. 初始化Winsock套接字库

```cpp
BOOL InitWsa()
{
    WORD wVersionRequested; // 定义请求的 Winsock 版本
    WSADATA wsaData; // Winsock 数据结构体
    int err; // 错误码
    wVersionRequested = MAKEWORD(2, 2); // 请求 Winsock 2.2 版本
    err = WSAStartup(wVersionRequested, &wsaData); // 初始化 Winsock
    if (err != 0)
    {
        printf("加载 winsock 失败， 错误代码为: %d\n", WSAGetLastError()); // 输出错误信息
        return FALSE; // 返回失败
    }
    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2)
    {
        printf("不能找到正确的 winsock 版本\n"); // 输出版本不正确信息
        WSACleanup(); // 释放 Winsock 资源
        return FALSE; // 返回失败
    }
    return TRUE; // 返回成功
}
```

这部分初始化2.2版本的Winsock
# 2.初始化套接字

```cpp
BOOL InitSocket()
{
    ProxyServer = socket(AF_INET, SOCK_STREAM, 0); // 创建代理服务器的 IPv4 TCP 套接字
    if (INVALID_SOCKET == ProxyServer)
    {
        printf("创建套接字失败，错误代码为：%d\n", WSAGetLastError()); // 输出错误信息
        return FALSE; // 返回失败
    }
    ProxyServerAddr.sin_family = AF_INET; // 设置为 IPv4 地址族
    ProxyServerAddr.sin_port = htons(ProxyPort); // 设置代理服务器的端口号，使用 htons 转换为网络字节序
    ProxyServerAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); // 设置代理服务器只允许本机访问
    // 绑定端点地址和套接字
    if (bind(ProxyServer, (SOCKADDR*)&ProxyServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)//sizeof是被bind()提供地址结构体大小，也可以是ProxyServerAddr的大小
    {
        printf("绑定套接字失败\n"); // 输出绑定失败信息
        return FALSE; // 返回失败
    }
    //进入监听状态
    if (listen(ProxyServer, SOMAXCONN) == SOCKET_ERROR)//SOMAXCONN是连接请求等待队列的最大长度
        
    {
        printf("监听端口%d 失败", ProxyPort); // 输出监听失败信息
        return FALSE; // 返回失败
    }
    return TRUE; // 返回成功
}
```

1. `socket()`新建套接字，传入`AF_INET`代表IPv4，`SOCK_STREAM`代表TCP
2. `ProxyServerAddr`存放信息，包括地址族，代理服务器的端口号（用`htons`转换字符串），代理服务器接收的ip地址（用`inet_addr`转换字符串）
3. `bind()`把gang'chuang